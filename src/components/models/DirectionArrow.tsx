/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.10 .\public\models\indicators\DirectionArrow.glb -t 
*/

import { useLoader } from '@react-three/fiber';
import { useEffect, useMemo } from 'react';
import * as THREE from 'three';
import { EnemyTouchType, PathCurves } from '../types/GameTypes';

type DirectionArrowType = JSX.IntrinsicElements['group'] & {
  curveType?: PathCurves;
  touchType: EnemyTouchType;
};

export default function DirectionArrow(props: DirectionArrowType) {
  const rows = 2;
  const cols = 2;

  const damageSpriteSheet = useLoader(
    THREE.TextureLoader,
    '/textures/ArrowsOverLay.png'
  );
  const statusSpriteSheet = useLoader(
    THREE.TextureLoader,
    '/textures/StatusArrowsOverLay.png'
  );

  const spriteSheet = useMemo(() => {
    if (props.touchType === EnemyTouchType.TOUCHTYPE_DAMAGE) {
      return damageSpriteSheet.clone();
    }
    return statusSpriteSheet.clone();
  }, [damageSpriteSheet, props.touchType, statusSpriteSheet]);

  spriteSheet.minFilter = THREE.NearestFilter;

  spriteSheet.repeat.x = 1 / cols;
  spriteSheet.repeat.y = 1 / rows;

  useEffect(() => {
    let col = 0;
    let row = 0;

    switch (props.curveType) {
      case PathCurves.PATH_ORIGIN:
        row = 0;
        col = 0;
        break;
      case PathCurves.PATH_DESTINATION:
        row = 1;
        col = 0;
        break;
      case PathCurves.PATH_CURVE:
        row = 0;
        col = 1;
        break;
      case PathCurves.PATH_STRAIGHT:
        row = 1;
        col = 1;
        break;
      default:
        [row, col] = [0, 0];
        break;
    }

    spriteSheet.offset.x = col / cols;
    spriteSheet.offset.y = 1 - (1 + row) / rows;
  }, [props.curveType, spriteSheet.offset]);

  return (
    <group {...props} dispose={null}>
      <mesh rotation={[THREE.MathUtils.degToRad(270), 0, 0]}>
        <planeGeometry attach="geometry" args={[1, 1]} />
        <meshBasicMaterial
          attach="material"
          side={THREE.FrontSide}
          map={spriteSheet}
          transparent
        />
      </mesh>
    </group>
  );
}
