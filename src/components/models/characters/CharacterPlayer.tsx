/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.10 ./public/character-human.glb -t 
*/

import { MovedEvent } from '@/components/entities/MoveableObject';
import useGameObjectEvent from '@/components/entities/useGameObjectEvent';
import {
  ENTITY_ALIVE,
  ENTITY_DIED,
  EntityAliveEvent,
  EntityDiedEvent,
} from '@/components/types/EventTypes';
import { useStore } from '@/stores/useStore';
import { useAnimations, useGLTF } from '@react-three/drei';
import { Vector3 } from '@react-three/fiber';
import { useEffect, useRef, useState } from 'react';
import * as THREE from 'three';
import { Group } from 'three';
import { GLTF } from 'three-stdlib';

interface GLTFAction extends THREE.AnimationClip {
  name: ActionName;
}

type GLTFResult = GLTF & {
  nodes: {
    ['leg-left']: THREE.Mesh;
    ['leg-right']: THREE.Mesh;
    torso: THREE.Mesh;
    ['arm-left']: THREE.Mesh;
    ['arm-right']: THREE.Mesh;
    head: THREE.Mesh;
  };
  materials: {
    colormap: THREE.MeshStandardMaterial;
  };
  animations: GLTFAction[];
};

type ActionName =
  | 'static'
  | 'idle'
  | 'walk'
  | 'sprint'
  | 'jump'
  | 'fall'
  | 'crouch'
  | 'sit'
  | 'drive'
  | 'die'
  | 'pick-up'
  | 'emote-yes'
  | 'emote-no'
  | 'holding-right'
  | 'holding-left'
  | 'holding-both'
  | 'holding-right-shoot'
  | 'holding-left-shoot'
  | 'holding-both-shoot'
  | 'attack-melee-right'
  | 'attack-melee-left'
  | 'attack-kick-right'
  | 'attack-kick-left'
  | 'interact-right'
  | 'interact-left';

type CharacterPlayerProps = {
  desiredPosition?: Vector3;
};

export function CharacterPlayer(
  props: JSX.IntrinsicElements['group'] & CharacterPlayerProps
) {
  const movePlayerLocation = useStore((state) => state.movePlayerLocation);
  const human = useRef<Group>(null);
  // eslint-disable-next-line react-hooks/exhaustive-deps
  //const position = useMemo(() => props.position, []);
  const { nodes, materials, animations } = useGLTF(
    '/models/characters/human/character-human.glb'
  ) as GLTFResult;
  const { actions } = useAnimations(animations, human);
  const [animation, setAnimation] = useState<ActionName>('idle');

  //const { nodeRef } = useGameObject();

  /*useGameObjectEvent<MovingEvent>(
    'moving',
    ({ currentPosition, nextPosition }) => {
      console.log(
        'Current position: ',
        currentPosition,
        ' Going to ',
        nextPosition
      );
    }
  );*/

  useGameObjectEvent<MovedEvent>('moved', (data) => {
    //console.log('Finished moving to:', data);
    movePlayerLocation(data, false);
  });

  useGameObjectEvent<EntityDiedEvent>(ENTITY_DIED, () => {
    actions[animation]?.fadeOut(0.32);
    const anim = actions['die']?.reset().setLoop(THREE.LoopOnce, 1).play();
    if (anim) {
      anim.clampWhenFinished = true;
    }
  });

  useGameObjectEvent<EntityAliveEvent>(ENTITY_ALIVE, () => {
    // Reverse the die animation
    actions['die']?.fadeOut(0.32);
    console.log('[CharacterPlayer] SO ALIVE RIGHT NOW');
    actions['idle']?.reset().fadeIn(0.32).play();
    setAnimation('idle');
  });

  // Transition through animations
  useEffect(() => {
    if (!actions) {
      return () => {};
    } else {
      actions[animation]?.reset().fadeIn(0.32).play();
      return () => actions[animation]?.fadeOut(0.32);
    }
  }, [actions, animation]);

  /*useFrame(() => {
    if (!human || !human.current) {
      return;
    }
    const propsPosition = props.position as THREE.Vector3;
    if (
      props.position &&
      human.current?.position.distanceTo(propsPosition) > 0.1
    ) {
      human.current.lookAt(propsPosition);
      human.current?.position.lerp(propsPosition, 0.1);
      setAnimation('walk');
    } else {
      setAnimation('idle');
    }
  });*/

  return (
    <group {...props} dispose={null} ref={human}>
      <group name="character-human">
        <group name="character-human_1">
          <group name="root">
            <mesh
              name="leg-left"
              geometry={nodes['leg-left'].geometry}
              material={materials.colormap}
              position={[0.084, 0.176, -0.024]}
            />
            <mesh
              name="leg-right"
              geometry={nodes['leg-right'].geometry}
              material={materials.colormap}
              position={[-0.084, 0.176, -0.024]}
            />
            <mesh
              name="torso"
              geometry={nodes.torso.geometry}
              material={materials.colormap}
              position={[0, 0.176, -0.024]}
            >
              <mesh
                name="arm-left"
                geometry={nodes['arm-left'].geometry}
                material={materials.colormap}
                position={[0.1, 0.112, 0.011]}
              />
              <mesh
                name="arm-right"
                geometry={nodes['arm-right'].geometry}
                material={materials.colormap}
                position={[-0.1, 0.112, 0.011]}
              />
              <mesh
                name="head"
                geometry={nodes.head.geometry}
                material={materials.colormap}
                position={[0, 0.167, 0.026]}
              />
            </mesh>
          </group>
        </group>
      </group>
    </group>
  );
}

useGLTF.preload('/models/characters/human/character-human.glb');
