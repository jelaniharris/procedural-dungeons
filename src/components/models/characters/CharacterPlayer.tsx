/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.10 ./public/character-human.glb -t 
*/

import { MovedEvent } from '@/components/entities/MoveableObject';
import useGameObjectEvent from '@/components/entities/useGameObjectEvent';
import {
  ENTITY_ALIVE,
  ENTITY_DIED,
  EntityAliveEvent,
  EntityDiedEvent,
  PlayAnimationEvent,
} from '@/components/types/EventTypes';
import { useStore } from '@/stores/useStore';
import { useAnimations, useGLTF } from '@react-three/drei';
import { Vector3 } from '@react-three/fiber';
import { useCallback, useEffect, useRef, useState } from 'react';
import * as THREE from 'three';
import { Group } from 'three';
import { GLTF } from 'three-stdlib';

interface GLTFAction extends THREE.AnimationClip {
  name: ActionName;
}

type GLTFResult = GLTF & {
  nodes: {
    ['leg-left']: THREE.Mesh;
    ['leg-right']: THREE.Mesh;
    torso: THREE.Mesh;
    ['arm-left']: THREE.Mesh;
    ['arm-right']: THREE.Mesh;
    head: THREE.Mesh;
  };
  materials: {
    colormap: THREE.MeshStandardMaterial;
  };
  animations: GLTFAction[];
};

type ActionName =
  | 'static'
  | 'idle'
  | 'walk'
  | 'sprint'
  | 'jump'
  | 'fall'
  | 'crouch'
  | 'sit'
  | 'drive'
  | 'die'
  | 'pick-up'
  | 'emote-yes'
  | 'emote-no'
  | 'holding-right'
  | 'holding-left'
  | 'holding-both'
  | 'holding-right-shoot'
  | 'holding-left-shoot'
  | 'holding-both-shoot'
  | 'attack-melee-right'
  | 'attack-melee-left'
  | 'attack-kick-right'
  | 'attack-kick-left'
  | 'interact-right'
  | 'interact-left';

type CharacterPlayerProps = {
  desiredPosition?: Vector3;
};

export function CharacterPlayer(
  props: JSX.IntrinsicElements['group'] & CharacterPlayerProps
) {
  const movePlayerLocation = useStore((state) => state.movePlayerLocation);
  const human = useRef<Group>(null);
  // eslint-disable-next-line react-hooks/exhaustive-deps
  //const position = useMemo(() => props.position, []);
  const { nodes, materials, animations } = useGLTF(
    '/models/characters/human/character-human.glb'
  ) as GLTFResult;
  const { actions, mixer } = useAnimations(animations, human);
  const [animation, setAnimation] = useState<ActionName>('idle');
  const [animationStack, setAnimationStack] = useState<ActionName[]>([]);
  const callbackReady = useRef(false);

  //const { nodeRef } = useGameObject();

  /*useGameObjectEvent<MovingEvent>(
    'moving',
    ({ currentPosition, nextPosition }) => {
      console.log(
        'Current position: ',
        currentPosition,
        ' Going to ',
        nextPosition
      );
    }
  );*/

  const popAnimationFromStack = useCallback(() => {
    if (animationStack.length > 0) {
      const nextAnimation = animationStack.shift();
      if (nextAnimation) {
        setAnimation(nextAnimation);
      }
      setAnimationStack(animationStack);
    } else {
      console.log('Nothing in animationStack. Current anim:', animation);
      if (animation != 'idle') setAnimation('idle');
      /*if (e.action._clip.name !== 'idle') {
        setAnimation('idle');
      }*/
    }
  }, [animation, animationStack]);

  useGameObjectEvent<MovedEvent>('moved', ({ location, rotation, zOffset }) => {
    //console.log('Finished moving to:', data);
    movePlayerLocation(location, rotation, false, zOffset);
  });

  useGameObjectEvent<PlayAnimationEvent>('play-animation', ({ animName }) => {
    console.log('Adding animation to a stack: ', animName);
    const newAnimationStack = [...animationStack, animName as ActionName];
    setAnimationStack(newAnimationStack);
  });

  useGameObjectEvent<EntityDiedEvent>(ENTITY_DIED, () => {
    actions[animation]?.fadeOut(0.32);
    const anim = actions['die']?.reset().setLoop(THREE.LoopOnce, 1).play();
    if (anim) {
      anim.clampWhenFinished = true;
    }
  });

  useGameObjectEvent<EntityAliveEvent>(ENTITY_ALIVE, () => {
    // Reverse the die animation
    actions['die']?.fadeOut(0.32);
    console.log('[CharacterPlayer] SO ALIVE RIGHT NOW');
    actions['idle']?.reset().fadeIn(0.32).play();
    setAnimation('idle');
  });

  const onFinishedAnimation = useCallback(
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    (e: any) => {
      const action = e.action;
      console.log('Animation finished: ', action.getClip()?.name);

      popAnimationFromStack();
    },
    [popAnimationFromStack]
  );

  const onStartedAnimation = useCallback(
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    (e: any) => {
      const action = e.action;
      console.log('Animation started: ', action.getClip()?.name);
    },
    []
  );

  useEffect(() => {
    console.log('%c RUNNING MIXER', 'color:green');

    if (!callbackReady.current) {
      console.log('%c CREATING EVENT MIXER', 'color:orange');
      mixer.addEventListener('finished', onFinishedAnimation);
      mixer.addEventListener('start', onStartedAnimation);
      callbackReady.current = true;
    }

    return () => {
      console.log('%c REMOVING MIXER', 'color:purple');
      if (callbackReady.current) {
        mixer.removeEventListener('finished', onFinishedAnimation);
        mixer.removeEventListener('start', onStartedAnimation);
        callbackReady.current = false;
      }
    };
  }, [mixer, onFinishedAnimation, onStartedAnimation]);

  useEffect(() => {
    if (animation == 'idle' || animation == 'die') {
      console.log('Animation is base, so pop new anim from stack');
      popAnimationFromStack();
    }
  }, [animation, animationStack, popAnimationFromStack]);

  // Transition through animations
  useEffect(() => {
    if (!actions) {
      return () => {};
    } else {
      //const action = mixer.clipAction(actions[animation]);
      //action.reset().fadeIn(0.32).play();

      const animAction = actions[animation];

      if (!animAction) {
        console.error('Could not find anim for ', animation);
        return;
      }

      if (
        ['attack-melee-left', 'attack-melee-right', 'fall'].includes(animation)
      ) {
        animAction.reset().setLoop(THREE.LoopOnce, 1).fadeIn(0.32);
        console.log('Playing animation once');
      } else {
        animAction.reset().setLoop(THREE.LoopRepeat, Infinity).fadeIn(0.32);
        console.log('Playing on repeat');
      }

      animAction.play();

      return () => actions[animation]?.fadeOut(0.32);
    }
  }, [actions, animation, mixer]);

  /*useFrame(() => {
    if (!human || !human.current) {
      return;
    }
    const propsPosition = props.position as THREE.Vector3;
    if (
      props.position &&
      human.current?.position.distanceTo(propsPosition) > 0.1
    ) {
      human.current.lookAt(propsPosition);
      human.current?.position.lerp(propsPosition, 0.1);
      setAnimation('walk');
    } else {
      setAnimation('idle');
    }
  });*/

  return (
    <group {...props} dispose={null} ref={human}>
      <group name="character-human">
        <group name="character-human_1">
          <group name="root">
            <mesh
              name="leg-left"
              geometry={nodes['leg-left'].geometry}
              material={materials.colormap}
              position={[0.084, 0.176, -0.024]}
            />
            <mesh
              name="leg-right"
              geometry={nodes['leg-right'].geometry}
              material={materials.colormap}
              position={[-0.084, 0.176, -0.024]}
            />
            <mesh
              name="torso"
              geometry={nodes.torso.geometry}
              material={materials.colormap}
              position={[0, 0.176, -0.024]}
            >
              <mesh
                name="arm-left"
                geometry={nodes['arm-left'].geometry}
                material={materials.colormap}
                position={[0.1, 0.112, 0.011]}
              />
              <mesh
                name="arm-right"
                geometry={nodes['arm-right'].geometry}
                material={materials.colormap}
                position={[-0.1, 0.112, 0.011]}
              />
              <mesh
                name="head"
                geometry={nodes.head.geometry}
                material={materials.colormap}
                position={[0, 0.167, 0.026]}
              />
            </mesh>
          </group>
        </group>
      </group>
    </group>
  );
}

useGLTF.preload('/models/characters/human/character-human.glb');
